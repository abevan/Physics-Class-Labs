<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Chosen Palette: Futuristic Neon -->
    <!-- Application Structure Plan: The application is now a game-like challenge. On load, it generates a right-triangle path with three icon waypoints. The user's task is to draw the two legs of the triangle, connecting the icons. The app then automatically calculates and displays the hypotenuse (displacement). This structure gamifies the learning process, making the relationship between distance (the two legs) and displacement (the hypotenuse) intuitive and interactive. -->
    <!-- Visualization & Content Choices: 
        - Report Info: A pre-defined right-triangle path. Goal: Challenge/Guide. Viz: Three Unicode icons placed at the vertices of a random right-angle triangle. Interaction: Icons are generated on "Clear Path." Justification: Creates a clear, repeatable challenge for the user, directly teaching the Pythagorean relationship between distance and displacement. Library: Vanilla JS.
        - Report Info: User-drawn path connecting icons. Goal: Interact/Solve. Viz: Solid blue lines connecting the icons. Interaction: User clicks and drags between icons; a "snapping" feature makes connecting them easy. Justification: Provides a satisfying and goal-oriented user action. Library: Vanilla JS Canvas API.
        - Report Info: Automatically generated hypotenuse. Goal: Compare/Inform. Viz: A dashed red line connecting the start and end icons. Interaction: Appears automatically after the user draws the first leg. Justification: Provides immediate visual feedback contrasting the path taken with the direct displacement. Library: Vanilla JS Canvas API.
        - CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Physics Lab: Displacement Challenge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            background-color: #0f172a;
            overflow-x: hidden;
        }
        canvas {
            touch-action: none;
            cursor: crosshair;
        }
        .glowing-box {
            position: relative;
        }
        .glowing-box::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 16px;
            padding: 2px;
            background: linear-gradient(45deg, #6366f1, #a855f7);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            z-index: -1;
            animation: glow 5s linear infinite;
        }
        @keyframes glow {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }
        .button-glow-light {
            position: relative;
            z-index: 10;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        .button-glow-light::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300%;
            height: 300%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 60%);
            transform: translate(-50%, -50%) scale(0);
            transition: transform 0.5s ease;
        }
        .button-glow-light:hover::before {
            transform: translate(-50%, -50%) scale(1);
        }
        .draw-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.2);
            font-size: 2rem;
            font-weight: bold;
            pointer-events: none;
            z-index: 5;
            transition: opacity 0.5s ease-in-out;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }
        .lab-canvas {
            background-size: 20px 20px;
            background-image: linear-gradient(to right, #273347 1px, transparent 1px),
                              linear-gradient(to bottom, #273347 1px, transparent 1px);
            animation: grid-pulse 10s infinite linear;
        }
        @keyframes grid-pulse {
            0% { background-position: 0 0; }
            100% { background-position: 20px 20px; }
        }
        .floating-blob {
            position: absolute;
            background: rgba(147, 51, 234, 0.5);
            border-radius: 50%;
            filter: blur(80px);
            opacity: 0.5;
            animation: float-up 15s infinite ease-in-out;
            z-index: 0;
        }
        .floating-blob.one {
            width: 300px;
            height: 300px;
            top: -50px;
            left: -50px;
            animation-duration: 18s;
        }
        .floating-blob.two {
            width: 200px;
            height: 200px;
            bottom: -50px;
            right: -50px;
            animation-duration: 22s;
            animation-delay: -5s;
        }
        @keyframes float-up {
            0% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-50px) scale(1.1); }
            100% { transform: translateY(0) scale(1); }
        }
    </style>
</head>
<body class="text-white flex flex-col items-center justify-start min-h-screen p-4">
    <div class="floating-blob one"></div>
    <div class="floating-blob two"></div>

    <div class="max-w-4xl w-full flex flex-col items-center justify-center gap-6 relative z-10">
        
        <div id="mainContent" class="w-full flex flex-col items-center">
            <h1 class="text-3xl sm:text-4xl font-extrabold text-white mb-2 text-center text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500">
                Displacement Challenge
            </h1>
            <p class="text-gray-300 text-base sm:text-lg text-center max-w-2xl mb-6">
                Connect the icons to complete the path! The <span class="text-blue-400 font-semibold">blue line</span> is the distance you travel, and the <span class="text-red-400 font-semibold">red line</span> is the direct displacement.
            </p>

            <div class="flex flex-col sm:flex-row gap-4 mb-6 text-center w-full">
                <div class="bg-gray-800 p-4 rounded-2xl shadow-xl flex-1 border-t border-gray-700 glowing-box">
                    <h2 class="text-xl font-bold text-gray-300">Total Distance (Scalar)</h2>
                    <p id="distance" class="text-2xl font-mono text-blue-400 mt-2">0.00</p>
                </div>
                <div class="bg-gray-800 p-4 rounded-2xl shadow-xl flex-1 border-t border-gray-700 glowing-box">
                    <h2 class="text-xl font-bold text-gray-300">Displacement (Vector)</h2>
                    <p id="displacement" class="text-2xl font-mono text-red-400 mt-2">0.00</p>
                </div>
            </div>

            <div class="w-full aspect-video bg-gray-800 rounded-2xl shadow-2xl relative overflow-hidden glowing-box">
                <canvas id="physicsCanvas" class="absolute inset-0 w-full h-full lab-canvas"></canvas>
                <div id="drawLabel" class="draw-label opacity-0 pointer-events-none">Connect the Dots!</div>
            </div>
            
            <div class="mt-6 flex flex-wrap justify-center gap-4">
                <button id="clearBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-full transition-all shadow-md button-glow-light">
                    <span class="mr-2">🔄</span>New Challenge
                </button>
            </div>
        </div>

    </div>

    <script>
        const mainCanvas = document.getElementById('physicsCanvas');
        const mainCtx = mainCanvas.getContext('2d');
        const distanceEl = document.getElementById('distance');
        const displacementEl = document.getElementById('displacement');
        const clearBtn = document.getElementById('clearBtn');
        const drawLabel = document.getElementById('drawLabel');
        const mainScaleFactor = 0.05;
        const snapRadius = 30;
        
        let isMainDrawing = false;
        let drawnPoints = [];
        let targetPoints = [];
        let currentDragPoint = null;
        let mainAnimFrame;

        function resizeMainCanvas() {
            mainCanvas.width = mainCanvas.offsetWidth;
            mainCanvas.height = mainCanvas.offsetHeight;
            if (targetPoints.length === 0) {
                generateTrianglePoints();
            }
        }

        function generateTrianglePoints() {
            const padding = 80;
            const w = mainCanvas.width - padding * 2;
            const h = mainCanvas.height - padding * 2;

            const p1 = {
                x: padding + Math.random() * w * 0.4,
                y: padding + Math.random() * h
            };

            const p2 = {};
            const p3 = {};

            if (Math.random() > 0.5) {
                p2.x = p1.x;
                p2.y = padding + Math.random() * h * 0.4;
                p3.x = padding + w * 0.6 + Math.random() * w * 0.4;
                p3.y = p2.y;
            } else {
                p2.x = padding + w * 0.6 + Math.random() * w * 0.4;
                p2.y = p1.y;
                p3.x = p2.x;
                p3.y = padding + h * 0.6 + Math.random() * h * 0.4;
            }
            
            targetPoints = [p1, p2, p3];
            drawnPoints = [p1];
        }

        function getEventPos(event, canvas) {
            const rect = canvas.getBoundingClientRect();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function startMainDraw(e) {
            e.preventDefault();
            const pos = getEventPos(e, mainCanvas);
            const lastDrawnPoint = drawnPoints[drawnPoints.length - 1];
            const dist = Math.hypot(pos.x - lastDrawnPoint.x, pos.y - lastDrawnPoint.y);

            if (dist < snapRadius && drawnPoints.length < 3) {
                isMainDrawing = true;
                currentDragPoint = { x: pos.x, y: pos.y };
            }
        }

        function continueMainDraw(e) {
            if (!isMainDrawing) return;
            e.preventDefault();
            const pos = getEventPos(e, mainCanvas);
            currentDragPoint = { x: pos.x, y: pos.y };

            const nextTarget = targetPoints[drawnPoints.length];
            if (nextTarget) {
                const distToTarget = Math.hypot(pos.x - nextTarget.x, pos.y - nextTarget.y);
                if (distToTarget < snapRadius) {
                    currentDragPoint = { x: nextTarget.x, y: nextTarget.y };
                }
            }
        }

        function endMainDraw() {
            if (!isMainDrawing) return;
            isMainDrawing = false;
            
            const nextTarget = targetPoints[drawnPoints.length];
            if (nextTarget && currentDragPoint) {
                 const distToTarget = Math.hypot(currentDragPoint.x - nextTarget.x, currentDragPoint.y - nextTarget.y);
                 if (distToTarget < snapRadius) {
                     drawnPoints.push(nextTarget);
                 }
            }
            currentDragPoint = null;
        }
        
        function drawTextLabel(ctx, text, x, y, color, font = 'bold 16px Inter') {
            ctx.font = font;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const textMetrics = ctx.measureText(text);
            const boxHeight = 24;
            const boxWidth = textMetrics.width + 16;
            const boxY = y - boxHeight - 8;
            ctx.fillStyle = 'rgba(15, 23, 42, 0.8)';
            ctx.fillRect(x - boxWidth / 2, boxY, boxWidth, boxHeight);
            ctx.fillStyle = color;
            ctx.fillText(text, x, boxY + boxHeight / 2);
        }
        
        function drawPathWithLabels(ctx, points, color) {
            if (points.length < 2) return;
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();

            for (let i = 1; i < points.length; i++) {
                const p1 = points[i - 1];
                const p2 = points[i];
                const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y) * mainScaleFactor;
                drawTextLabel(ctx, dist.toFixed(2), (p1.x + p2.x) / 2, (p1.y + p2.y) / 2, '#a5b4fc');
            }
        }
        
        function drawDisplacementWithLabel(ctx, p1, p2, color) {
            if (!p1 || !p2) return;
            ctx.setLineDash([10, 5]);
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            ctx.setLineDash([]);
            
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
            const arrowSize = 15;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(p2.x, p2.y);
            ctx.lineTo(p2.x - arrowSize * Math.cos(angle - Math.PI / 6), p2.y - arrowSize * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(p2.x - arrowSize * Math.cos(angle + Math.PI / 6), p2.y - arrowSize * Math.sin(angle + Math.PI / 6));
            ctx.fill();

            const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y) * mainScaleFactor;
            drawTextLabel(ctx, dist.toFixed(2), (p1.x + p2.x) / 2, (p1.y + p2.y) / 2, '#fca5a5');
        }

        function drawIcons(ctx, tPoints, dPoints) {
            const icons = ['🏠', '📍', '🏁'];
            const colors = ['#60a5fa', '#e5e7eb', '#f87171'];
            
            tPoints.forEach((point, i) => {
                const isDrawn = i < dPoints.length;
                const now = Date.now();
                const radius = isDrawn ? 8 + Math.sin(now / 200) * 2 : 12;
                const glow = isDrawn ? 12 + Math.sin(now / 200) * 5 : 0;
                
                ctx.beginPath();
                ctx.arc(point.x, point.y, radius, 0, 2 * Math.PI);
                ctx.fillStyle = colors[i];
                ctx.shadowColor = colors[i];
                ctx.shadowBlur = glow;
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.font = '24px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(icons[i], point.x, point.y);
            });
        }
        
        function calculateAndDisplayMain() {
            let totalDistance = 0;
            for (let i = 1; i < drawnPoints.length; i++) {
                totalDistance += Math.hypot(drawnPoints[i].x - drawnPoints[i-1].x, drawnPoints[i].y - drawnPoints[i-1].y);
            }
            const displacementValue = (drawnPoints.length > 1) ? Math.hypot(drawnPoints[drawnPoints.length - 1].x - drawnPoints[0].x, drawnPoints[drawnPoints.length - 1].y - drawnPoints[0].y) : 0;
            
            animateNumber(distanceEl, parseFloat(distanceEl.textContent), totalDistance * mainScaleFactor);
            animateNumber(displacementEl, parseFloat(displacementEl.textContent), displacementValue * mainScaleFactor);
        }

        function animateNumber(element, startValue, endValue, duration = 200) {
            const startTime = performance.now();
            const range = endValue - startValue;
            if (Math.abs(range) < 0.01 && Math.abs(parseFloat(element.textContent) - endValue) < 0.01) return;
            const animate = (currentTime) => {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const currentValue = startValue + range * progress;
                element.textContent = currentValue.toFixed(2);
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    element.textContent = endValue.toFixed(2);
                }
            };
            requestAnimationFrame(animate);
        }

        function mainLoop() {
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
            
            drawPathWithLabels(mainCtx, drawnPoints, '#60a5fa');
            
            if (isMainDrawing && currentDragPoint && drawnPoints.length > 0) {
                 const lastPoint = drawnPoints[drawnPoints.length - 1];
                 const dynamicPath = [lastPoint, currentDragPoint];
                 drawPathWithLabels(mainCtx, dynamicPath, '#60a5fa');
            }

            if (drawnPoints.length > 1) {
                drawDisplacementWithLabel(mainCtx, drawnPoints[0], drawnPoints[drawnPoints.length - 1], '#f87171');
            }

            drawIcons(mainCtx, targetPoints, drawnPoints);
            calculateAndDisplayMain();
            mainAnimFrame = requestAnimationFrame(mainLoop);
        }

        function clearMainPath() {
            generateTrianglePoints();
        }
        
        window.addEventListener('resize', resizeMainCanvas);
        clearBtn.addEventListener('click', clearMainPath);
        
        mainCanvas.addEventListener('mousedown', startMainDraw);
        mainCanvas.addEventListener('mousemove', continueMainDraw);
        document.addEventListener('mouseup', endMainDraw);
        
        mainCanvas.addEventListener('touchstart', startMainDraw, { passive: false });
        mainCanvas.addEventListener('touchmove', continueMainDraw, { passive: false });
        document.addEventListener('touchend', endMainDraw);
        
        window.onload = function() {
            resizeMainCanvas();
            mainLoop();
        };
    </script>
</body>
</html>

