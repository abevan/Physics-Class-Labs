<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Chosen Palette: Futuristic Neon -->
    <!-- Application Structure Plan: The application is a single-purpose lab focused on the core concepts of distance and displacement. The UI is simplified to a single view, removing tabs to eliminate distractions. Key information (live calculations) remains positioned above the interactive canvas for immediate feedback. The AI explanation feature has been removed to further streamline the user experience. -->
    <!-- Visualization & Content Choices: 
        - Report Info: User's multi-segment path. Goal: Inform/Explore. Viz: A series of connected lines on an HTML canvas. Interaction: User clicks and drags to create continuous path segments. Justification: Allows for a more complex exploration of how a winding path (distance) relates to the direct start-to-end measurement (displacement). Library: Vanilla JS Canvas API.
        - Report Info: Real-time length of each path segment. Goal: Inform. Viz: Text labels rendered directly on the canvas next to each line. Interaction: Labels appear and update as the user draws, now larger and always upright for readability. Justification: Provides immediate, contextual feedback on the length of each step of the journey. Library: Vanilla JS Canvas API.
        - Report Info: Real-time total displacement. Goal: Compare. Viz: A dashed red line and a real-time text label on the canvas. Interaction: The line and its label update continuously as the user draws the path. Justification: Visually and numerically contrasts the ever-growing path distance with the direct displacement value. Library: Vanilla JS Canvas API.
        - CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Physics Lab: Displacement & Distance</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            background-color: #0f172a;
            overflow-x: hidden;
        }
        canvas {
            touch-action: none;
        }
        .glowing-box {
            position: relative;
        }
        .glowing-box::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 16px;
            padding: 2px;
            background: linear-gradient(45deg, #6366f1, #a855f7);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            z-index: -1;
            animation: glow 5s linear infinite;
        }
        @keyframes glow {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }
        .button-glow-light {
            position: relative;
            z-index: 10;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        .button-glow-light::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300%;
            height: 300%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 60%);
            transform: translate(-50%, -50%) scale(0);
            transition: transform 0.5s ease;
        }
        .button-glow-light:hover::before {
            transform: translate(-50%, -50%) scale(1);
        }
        .draw-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.2);
            font-size: 2rem;
            font-weight: bold;
            pointer-events: none;
            z-index: 5;
            transition: opacity 0.5s ease-in-out;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }
        .lab-canvas {
            background-size: 20px 20px;
            background-image: linear-gradient(to right, #273347 1px, transparent 1px),
                              linear-gradient(to bottom, #273347 1px, transparent 1px);
            animation: grid-pulse 10s infinite linear;
        }
        @keyframes grid-pulse {
            0% { background-position: 0 0; }
            100% { background-position: 20px 20px; }
        }
        .floating-blob {
            position: absolute;
            background: rgba(147, 51, 234, 0.5);
            border-radius: 50%;
            filter: blur(80px);
            opacity: 0.5;
            animation: float-up 15s infinite ease-in-out;
            z-index: 0;
        }
        .floating-blob.one {
            width: 300px;
            height: 300px;
            top: -50px;
            left: -50px;
            animation-duration: 18s;
        }
        .floating-blob.two {
            width: 200px;
            height: 200px;
            bottom: -50px;
            right: -50px;
            animation-duration: 22s;
            animation-delay: -5s;
        }
        @keyframes float-up {
            0% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-50px) scale(1.1); }
            100% { transform: translateY(0) scale(1); }
        }
    </style>
</head>
<body class="text-white flex flex-col items-center justify-start min-h-screen p-4">
    <div class="floating-blob one"></div>
    <div class="floating-blob two"></div>

    <div class="max-w-4xl w-full flex flex-col items-center justify-center gap-6 relative z-10">
        
        <div id="mainContent" class="w-full flex flex-col items-center">
            <h1 class="text-3xl sm:text-4xl font-extrabold text-white mb-2 text-center text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500">
                Displacement Lab
            </h1>
            <p class="text-gray-300 text-base sm:text-lg text-center max-w-2xl mb-6">
                The <span class="text-blue-400 font-semibold">blue line</span> will show the total distance you've traveled, while the <span class="text-red-400 font-semibold">red line</span> shows your actual displacement.
            </p>

            <div class="flex flex-col sm:flex-row gap-4 mb-6 text-center w-full">
                <div class="bg-gray-800 p-4 rounded-2xl shadow-xl flex-1 border-t border-gray-700 glowing-box">
                    <h2 class="text-xl font-bold text-gray-300">Total Distance (Scalar)</h2>
                    <p id="distance" class="text-2xl font-mono text-blue-400 mt-2">0.00</p>
                </div>
                <div class="bg-gray-800 p-4 rounded-2xl shadow-xl flex-1 border-t border-gray-700 glowing-box">
                    <h2 class="text-xl font-bold text-gray-300">Displacement (Vector)</h2>
                    <p id="displacement" class="text-2xl font-mono text-red-400 mt-2">0.00</p>
                </div>
            </div>

            <div class="w-full aspect-video bg-gray-800 rounded-2xl shadow-2xl relative overflow-hidden glowing-box">
                <canvas id="physicsCanvas" class="absolute inset-0 w-full h-full lab-canvas"></canvas>
                <div id="drawLabel" class="draw-label">Click and Drag to Draw</div>
            </div>
            
            <div class="mt-6 flex flex-wrap justify-center gap-4">
                <button id="clearBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-full transition-all shadow-md button-glow-light">
                    <span class="mr-2">ðŸ§¹</span>Clear Path
                </button>
            </div>
        </div>

    </div>

    <script>
        const mainCanvas = document.getElementById('physicsCanvas');
        const mainCtx = mainCanvas.getContext('2d');
        const distanceEl = document.getElementById('distance');
        const displacementEl = document.getElementById('displacement');
        const clearBtn = document.getElementById('clearBtn');
        const drawLabel = document.getElementById('drawLabel');
        const mainScaleFactor = 0.05;
        
        let isMainDrawing = false;
        let mainPoints = [];
        let mainAnimFrame;

        function resizeMainCanvas() {
            mainCanvas.width = mainCanvas.offsetWidth;
            mainCanvas.height = mainCanvas.offsetHeight;
        }

        function getEventPos(event, canvas) {
            const rect = canvas.getBoundingClientRect();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function startMainDraw(e) {
            e.preventDefault();
            isMainDrawing = true;
            const pos = getEventPos(e, mainCanvas);
            
            if (mainPoints.length === 0) {
                mainPoints.push(pos);
            }
            mainPoints.push(pos);
            
            drawLabel.style.opacity = '0';
        }

        function continueMainDraw(e) {
            if (!isMainDrawing) return;
            e.preventDefault();
            mainPoints[mainPoints.length - 1] = getEventPos(e, mainCanvas);
            calculateAndDisplayMain();
        }

        function endMainDraw() {
            if (!isMainDrawing) return;
            isMainDrawing = false;
        }

        function drawTextLabel(ctx, text, x, y, color, font = 'bold 16px Inter') {
            ctx.font = font;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const textMetrics = ctx.measureText(text);
            const textHeight = 16; 
            const padding = 4;
            const boxWidth = textMetrics.width + padding * 2;
            const boxHeight = textHeight + padding * 2;
            const boxY = y - boxHeight - 8; 

            ctx.fillStyle = 'rgba(15, 23, 42, 0.8)';
            ctx.fillRect(x - boxWidth / 2, boxY, boxWidth, boxHeight);

            ctx.fillStyle = color;
            ctx.fillText(text, x, boxY + boxHeight / 2);
        }
        
        function drawPathWithLabels(ctx, points, color) {
            if (points.length < 2) return;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();

            for (let i = 1; i < points.length; i++) {
                const p1 = points[i - 1];
                const p2 = points[i];
                const dist = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)) * mainScaleFactor;
                const midX = (p1.x + p2.x) / 2;
                const midY = (p1.y + p2.y) / 2;
                drawTextLabel(ctx, dist.toFixed(2), midX, midY, '#a5b4fc');
            }
        }

        function drawDisplacementWithLabel(ctx, points, color, startLabel, endLabel) {
            if (points.length < 1) return;
            const startPoint = points[0];
            const endPoint = points[points.length - 1];
            
            ctx.setLineDash([10, 5]);
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            ctx.lineTo(endPoint.x, endPoint.y);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.font = 'bold 16px Inter';
            const drawPulsingCircle = (x, y, c, label) => {
                const now = Date.now();
                const radius = 6 + Math.sin(now / 200) * 1.5;
                const glow = 10 + Math.sin(now / 200) * 5;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fillStyle = c;
                ctx.shadowColor = c;
                ctx.shadowBlur = glow;
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#e5e7eb';
                ctx.fillText(label, x + 15, y - 15);
            };
            
            drawPulsingCircle(startPoint.x, startPoint.y, '#60a5fa', startLabel);
            if (points.length > 1) {
                drawPulsingCircle(endPoint.x, endPoint.y, '#f87171', endLabel);
                const angle = Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x);
                const arrowSize = 15;
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(endPoint.x, endPoint.y);
                ctx.lineTo(endPoint.x - arrowSize * Math.cos(angle - Math.PI / 6), endPoint.y - arrowSize * Math.sin(angle - Math.PI / 6));
                ctx.lineTo(endPoint.x - arrowSize * Math.cos(angle + Math.PI / 6), endPoint.y - arrowSize * Math.sin(angle + Math.PI / 6));
                ctx.fill();

                const displacementValue = Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2)) * mainScaleFactor;
                const midX = (startPoint.x + endPoint.x) / 2;
                const midY = (startPoint.y + endPoint.y) / 2;
                drawTextLabel(ctx, displacementValue.toFixed(2), midX, midY, '#fca5a5');
            }
        }
        
        function calculateAndDisplayMain() {
             if (mainPoints.length < 2) {
                animateNumber(distanceEl, parseFloat(distanceEl.textContent), 0);
                animateNumber(displacementEl, parseFloat(displacementEl.textContent), 0);
                return;
            }
            let totalDistance = 0;
            for (let i = 1; i < mainPoints.length; i++) {
                const dx = mainPoints[i].x - mainPoints[i - 1].x;
                const dy = mainPoints[i].y - mainPoints[i - 1].y;
                totalDistance += Math.sqrt(dx * dx + dy * dy);
            }
            const startPoint = mainPoints[0];
            const endPoint = mainPoints[mainPoints.length - 1];
            const dxDisplacement = endPoint.x - startPoint.x;
            const dyDisplacement = endPoint.y - startPoint.y;
            const displacementValue = Math.sqrt(dxDisplacement * dxDisplacement + dyDisplacement * dyDisplacement);
            animateNumber(distanceEl, parseFloat(distanceEl.textContent), totalDistance * mainScaleFactor);
            animateNumber(displacementEl, parseFloat(displacementEl.textContent), displacementValue * mainScaleFactor);
        }

        function animateNumber(element, startValue, endValue, duration = 200) {
            const startTime = performance.now();
            const range = endValue - startValue;
            if (range === 0 && parseFloat(element.textContent) === endValue) return;
            const animate = (currentTime) => {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const currentValue = startValue + range * progress;
                element.textContent = currentValue.toFixed(2);
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    element.textContent = endValue.toFixed(2);
                }
            };
            requestAnimationFrame(animate);
        }

        function mainLoop() {
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
            drawPathWithLabels(mainCtx, mainPoints, '#60a5fa');
            drawDisplacementWithLabel(mainCtx, mainPoints, '#f87171', 'START', 'END');
            mainAnimFrame = requestAnimationFrame(mainLoop);
        }

        function clearMainPath() {
            mainPoints = [];
            distanceEl.textContent = '0.00';
            displacementEl.textContent = '0.00';
            drawLabel.style.opacity = '1';
        }
        
        window.addEventListener('resize', resizeMainCanvas);
        clearBtn.addEventListener('click', clearMainPath);
        
        mainCanvas.addEventListener('mousedown', startMainDraw);
        mainCanvas.addEventListener('mousemove', continueMainDraw);
        document.addEventListener('mouseup', endMainDraw);
        mainCanvas.addEventListener('mouseleave', endMainDraw);
        
        mainCanvas.addEventListener('touchstart', startMainDraw, { passive: false });
        mainCanvas.addEventListener('touchmove', continueMainDraw, { passive: false });
        document.addEventListener('touchend', endMainDraw);
        
        window.onload = function() {
            resizeMainCanvas();
            mainLoop();
        };
    </script>
</body>
</html>

